[
    {
    "id": 1,
    "slug": "pilares-poo",
    "title": "Los 4 pilares fundamentales de la POO",
    "description": "La POO es un paradigma de programaciÃ³n que organiza el cÃ³digo en torno a objetos que representan entidades del mundo real o conceptual, Esta se basa en 4 pilares fundamentales.",
    "author": "Carlos Valencia",
    "date": "2025-06-11",
    "tags": ["poo", "programacion", "fundamentos"],
        "content": [
      {
        "subtitle": "IntroducciÃ³n",
        "contenido": "Â¿QuÃ© es la ProgramaciÃ³n Orientada a Objetos (POO)? \n La POO es un paradigma de programaciÃ³n que organiza el cÃ³digo en torno a objetos que representan entidades del mundo real o conceptual. Cada objeto contiene datos (atributos) y comportamiento (mÃ©todos). Este enfoque favorece la reutilizaciÃ³n de cÃ³digo, la mantenibilidad y la escalabilidad. <br> <br>"
      },
      {
        "subtitle": "Los 4 pilares fundamentales de la POO",
        "contenido": "<hr> <br> <br>"
      },
      {
        "subtitle": "1. ğŸ§¬ AbstracciÃ³n",
        "contenido": "Es el proceso de ocultar los detalles internos y mostrar solo lo necesario. Permite centrarse en \"quÃ© hace un objeto\" en lugar de \"cÃ³mo lo hace\". <br> <br>"
      },
      {
        "subtitle": "Ventajas de la abstracciÃ³n:",
        "contenido": "ğŸŸ¢ReducciÃ³n de complejidad. <br>ğŸŸ¢Mayor claridad y enfoque en el comportamiento esencial.<br>ğŸŸ¢Fomenta el uso de interfaces o clases abstractas.<br> <br>"
      },
      {
        "subtitle": "2. ğŸ›¡ï¸ Encapsulamiento",
        "contenido": "Es la prÃ¡ctica de ocultar los datos internos de un objeto y permitir el acceso solo a travÃ©s de mÃ©todos pÃºblicos (getters/setters).<br> <br>"
      },
      {
        "subtitle": "Ventajas del encapsulamiento:",
        "contenido": "ğŸŸ¢Control del acceso a los datos. <br>ğŸŸ¢Mejora la seguridad. <br>ğŸŸ¢Reduce el acoplamiento.<br> <br>"
      },
      {
        "subtitle": "3. ğŸ§¬ Herencia",
        "contenido": "Es la capacidad de una clase de heredar propiedades y comportamientos de otra clase. Promueve la reutilizaciÃ³n de cÃ³digo.<br> <br>"
      },
      {
        "subtitle": "Ventajas de la herencia:",
        "contenido": "ğŸŸ¢ReutilizaciÃ³n de cÃ³digo. <br>ğŸŸ¢OrganizaciÃ³n jerÃ¡rquica. <br>ğŸŸ¢Extensibilidad.<br> <br>"
      },
      {
        "subtitle": "4. ğŸ”„ Polimorfismo",
        "contenido": "Es la capacidad de un objeto de adoptar mÃºltiples formas. Es decir, una misma acciÃ³n puede comportarse de manera diferente segÃºn el contexto.<br> <br>"
      },
      {
        "subtitle": "Ventajas del polimorfismo:",
        "contenido": "ğŸŸ¢Mayor flexibilidad.<br>ğŸŸ¢CÃ³digo mÃ¡s limpio y reutilizable.<br>ğŸŸ¢Permite el uso de interfaces y clases base.<br> <br>"
      },
      {
        "subtitle": "Â¿Por quÃ© son importantes estos pilares?",
        "contenido": "ğŸŸ¢Permiten diseÃ±ar software robusto, escalable y mantenible.<br>ğŸŸ¢Separan las responsabilidades y mejoran el principio de responsabilidad Ãºnica.<br>ğŸŸ¢Hacen que el cÃ³digo sea mÃ¡s cercano a cÃ³mo pensamos los humanos en objetos y comportamientos.<br> <br>"
      },
      {
        "subtitle": "ConclusiÃ³n",
        "contenido": "La POO sigue siendo clave en la ingenierÃ­a de software moderna, especialmente en lenguajes como C#, Java, Python, C++. Comprender profundamente estos pilares es esencial para cualquier desarrollador que busque escribir cÃ³digo limpio, sÃ³lido y orientado al cambio.<br> <br>"
      }
    ]
  },
      {
    "id": 2,
    "slug": "principios-solid",
    "title": "Principios SOLID: GuÃ­a Completa",
    "description": "AquÃ­ tienes una guÃ­a completa y detallada sobre los Principios SOLID",
    "author": "Carlos Valencia",
    "date": "2025-06-13",
    "tags": ["solid", "programacion", "fundamentos"],

        "content": [
      {
        "subtitle": "Â¿QuÃ© es SOLID?",
        "contenido": "SOLID es un acrÃ³nimo que representa cinco principios fundamentales de la programaciÃ³n orientada a objetos, formulados por Robert C. Martin (conocido como â€œUncle Bobâ€). Estos principios tienen como objetivo escribir cÃ³digo:<br> <ul><li>MÃ¡s limpio</li>  <li>Mantenible</li> <li>Escalable</li> <li>FÃ¡cil de probar y extender</li></ul> <br> <br>"
      },
      {
        "subtitle": "1. Single Responsibility Principle (SRP)",
        "contenido": "â€œUna clase debe tener una Ãºnica razÃ³n para cambiar.â€<br><b>DefiniciÃ³n</b><br> Cada clase o mÃ³dulo debe encargarse de una Ãºnica funcionalidad o responsabilidad. Si una clase tiene mÃºltiples razones para cambiar, estÃ¡ haciendo mÃ¡s de lo que deberÃ­a.<br>"
      },{
        "subtitle": "2. Open/Closed Principle (OCP)",
        "contenido": "â€œLas entidades de software deben estar abiertas para extensiÃ³n, pero cerradas para modificaciÃ³n.â€<br><b>DefiniciÃ³n</b><br>El comportamiento de una clase debe poder extenderse sin necesidad de modificar su cÃ³digo original.<br>"
      },{
        "subtitle": "3. Liskov Substitution Principle (LSP)",
        "contenido": "â€œLos objetos de una clase derivada deben poder sustituir a los objetos de su clase base sin alterar el comportamiento esperado.â€<br><b>DefiniciÃ³n</b><br>Si una clase B hereda de A, deberÃ­a poder usarse donde sea que se use A, sin errores ni comportamientos inesperados.<br>"
      },{
        "subtitle": "4. Interface Segregation Principle (ISP)",
        "contenido": "â€œNingÃºn cliente debe verse obligado a depender de mÃ©todos que no utiliza.â€<br><b>DefiniciÃ³n</b><br>Las interfaces deben ser especÃ­ficas y pequeÃ±as, en lugar de contener mÃ©todos innecesarios para algunas clases.   <br>"
      },{
        "subtitle": "5. Dependency Inversion Principle (DIP)",
        "contenido": "Los mÃ³dulos de alto nivel no deben depender de mÃ³dulos de bajo nivel. Ambos deben depender de abstracciones.â€<br><b>DefiniciÃ³n</b><br> En lugar de que las clases dependan directamente de implementaciones concretas, deben depender de interfaces o abstracciones.<br>"
      },{
        "subtitle": "Beneficios de aplicar SOLID",
        "contenido": "<ul><li>CÃ³digo modular y reutilizable</li><li>Facilita el testing automatizado</li><li>Menor riesgo de bugs al modificar cÃ³digo</li><li>Mejora la colaboraciÃ³n en equipo</li><li>Escalabilidad y mantenimiento a largo lazo</li></ul>"
      },{
        "subtitle": "",
        "contenido": "<br> <br>"
      }
    ]
  }
  ]
