[
    {
    "id": 1,
    "slug": "pilares-poo",
    "title": "Los 4 pilares fundamentales de la POO",
    "description": "La POO es un paradigma de programaci√≥n que organiza el c√≥digo en torno a objetos que representan entidades del mundo real o conceptual, Esta se basa en 4 pilares fundamentales.",
    "author": "Carlos Valencia",
    "date": "2025-06-11",
    "tags": ["poo", "programacion", "fundamentos"],
        "content": [
      {
        "subtitle": "Introducci√≥n",
        "contenido": "¬øQu√© es la Programaci√≥n Orientada a Objetos (POO)? \n La POO es un paradigma de programaci√≥n que organiza el c√≥digo en torno a objetos que representan entidades del mundo real o conceptual. Cada objeto contiene datos (atributos) y comportamiento (m√©todos). Este enfoque favorece la reutilizaci√≥n de c√≥digo, la mantenibilidad y la escalabilidad. <br> <br>"
      },
      {
        "subtitle": "Los 4 pilares fundamentales de la POO",
        "contenido": "<hr> <br> <br>"
      },
      {
        "subtitle": "1. üß¨ Abstracci√≥n",
        "contenido": "Es el proceso de ocultar los detalles internos y mostrar solo lo necesario. Permite centrarse en \"qu√© hace un objeto\" en lugar de \"c√≥mo lo hace\". <br> <br>"
      },
      {
        "subtitle": "Ventajas de la abstracci√≥n:",
        "contenido": "üü¢Reducci√≥n de complejidad. <br>üü¢Mayor claridad y enfoque en el comportamiento esencial.<br>üü¢Fomenta el uso de interfaces o clases abstractas.<br> <br>"
      },
      {
        "subtitle": "2. üõ°Ô∏è Encapsulamiento",
        "contenido": "Es la pr√°ctica de ocultar los datos internos de un objeto y permitir el acceso solo a trav√©s de m√©todos p√∫blicos (getters/setters).<br> <br>"
      },
      {
        "subtitle": "Ventajas del encapsulamiento:",
        "contenido": "üü¢Control del acceso a los datos. <br>üü¢Mejora la seguridad. <br>üü¢Reduce el acoplamiento.<br> <br>"
      },
      {
        "subtitle": "3. üß¨ Herencia",
        "contenido": "Es la capacidad de una clase de heredar propiedades y comportamientos de otra clase. Promueve la reutilizaci√≥n de c√≥digo.<br> <br>"
      },
      {
        "subtitle": "Ventajas de la herencia:",
        "contenido": "üü¢Reutilizaci√≥n de c√≥digo. <br>üü¢Organizaci√≥n jer√°rquica. <br>üü¢Extensibilidad.<br> <br>"
      },
      {
        "subtitle": "4. üîÑ Polimorfismo",
        "contenido": "Es la capacidad de un objeto de adoptar m√∫ltiples formas. Es decir, una misma acci√≥n puede comportarse de manera diferente seg√∫n el contexto.<br> <br>"
      },
      {
        "subtitle": "Ventajas del polimorfismo:",
        "contenido": "üü¢Mayor flexibilidad.<br>üü¢C√≥digo m√°s limpio y reutilizable.<br>üü¢Permite el uso de interfaces y clases base.<br> <br>"
      },
      {
        "subtitle": "¬øPor qu√© son importantes estos pilares?",
        "contenido": "üü¢Permiten dise√±ar software robusto, escalable y mantenible.<br>üü¢Separan las responsabilidades y mejoran el principio de responsabilidad √∫nica.<br>üü¢Hacen que el c√≥digo sea m√°s cercano a c√≥mo pensamos los humanos en objetos y comportamientos.<br> <br>"
      },
      {
        "subtitle": "Conclusi√≥n",
        "contenido": "La POO sigue siendo clave en la ingenier√≠a de software moderna, especialmente en lenguajes como C#, Java, Python, C++. Comprender profundamente estos pilares es esencial para cualquier desarrollador que busque escribir c√≥digo limpio, s√≥lido y orientado al cambio.<br> <br>"
      }
    ]
  },
  {
    "id": 2,
    "slug": "principios-solid",
    "title": "Principios SOLID: Gu√≠a Completa",
    "description": "Aqu√≠ tienes una gu√≠a completa y detallada sobre los Principios SOLID",
    "author": "Carlos Valencia",
    "date": "2025-06-13",
    "tags": ["solid", "programacion", "fundamentos"],
        "content": [
      {
        "subtitle": "¬øQu√© es SOLID?",
        "contenido": "SOLID es un acr√≥nimo que representa cinco principios fundamentales de la programaci√≥n orientada a objetos, formulados por Robert C. Martin (conocido como ‚ÄúUncle Bob‚Äù). Estos principios tienen como objetivo escribir c√≥digo:<br> <ul><li>M√°s limpio</li>  <li>Mantenible</li> <li>Escalable</li> <li>F√°cil de probar y extender</li></ul>"
      },
      {
        "subtitle": "1. Single Responsibility Principle (SRP)",
        "contenido": "‚ÄúUna clase debe tener una √∫nica raz√≥n para cambiar.‚Äù<br><b>Definici√≥n</b><br> Cada clase o m√≥dulo debe encargarse de una √∫nica funcionalidad o responsabilidad. Si una clase tiene m√∫ltiples razones para cambiar, est√° haciendo m√°s de lo que deber√≠a.<br>"
      },
      {
        "subtitle": "Ejemplo en C# (Violando SRP)",
        "contenido": "<div class='codeSection'>public class Report<br>{<br>public string Title { get; set; }<br>public void GenerateReport() {* l√≥gica de generaci√≥n */ }<br>    public void SaveToFile() { /* l√≥gica de guardado en disco */ }<br>}</div><br>Esta clase viola SRP porque maneja tanto la l√≥gica del reporte como la persistencia."
      }
      ,
      {
        "subtitle": "Soluci√≥n SRP",
        "contenido": "<div class='codeSection'>public class Report<br>{<br>public string Title { get; set; }<br>public void GenerateReport() { /* <br>l√≥gica de generaci√≥n */ }<br>}<br>public class ReportSaver<br>{<br>public void SaveToFile(Report report) { /* guardar en disco */ }<br>}<br></div><br>"
      }
      ,{
        "subtitle": "2. Open/Closed Principle (OCP)",
        "contenido": "‚ÄúLas entidades de software deben estar abiertas para extensi√≥n, pero cerradas para modificaci√≥n.‚Äù<br><b>Definici√≥n</b><br>El comportamiento de una clase debe poder extenderse sin necesidad de modificar su c√≥digo original.<br>"
      },            
      {
        "subtitle": "Ejemplo en C# (Violando OCP)",
        "contenido": "<div class='codeSection'>public class DiscountCalculator<br>{<br>public double Calculate(string customerType)<br>{<br>        if (customerType == \"Regular\") return 0.1;<br>if (customerType == \"Premium\") return 0.2;<br>return 0;<br>}<br>}<br></div><br>Cada vez que se agregue un nuevo tipo de cliente, se debe modificar la clase."
      }
      ,
      {
        "subtitle": "Soluci√≥n OCP aplicado (usando polimorfismo)",
        "contenido": "<div class='codeSection'>public interface IDiscount<br>{<br>double GetDiscount();<br>}<br>public class RegularDiscount :IDiscount<br>{<br>public double GetDiscount() => 0.1;<br>}<br>public class PremiumDiscount : IDiscount<br>{<br>public double GetDiscount() => 0.2;<br>}<br><br>public class DiscountCalculator<br>{<br>public double Calculate(IDiscount discount) => discount.GetDiscount();<br>}<br></div><br>"
      },
      {
        "subtitle": "3. Liskov Substitution Principle (LSP)",
        "contenido": "‚ÄúLos objetos de una clase derivada deben poder sustituir a los objetos de su clase base sin alterar el comportamiento esperado.‚Äù<br><b>Definici√≥n</b><br>Si una clase B hereda de A, deber√≠a poder usarse donde sea que se use A, sin errores ni comportamientos inesperados.<br>"
      },
      
      
      
      {
        "subtitle": "Ejemplo en C# (Violando LSP)",
        "contenido": "<div class='codeSection'>public class Bird<br>{<br>public virtual void Fly() { }<br>}<br>public class Ostrich : Bird<br>{<br>  public override void Fly() => throw new NotImplementedException(); // Las avestruces no vuelan<br>}<br></div>Si usamos Ostrich como un Bird, provocar√° errores."
      }
      ,
      {
        "subtitle": "Soluci√≥n LSP",
        "contenido": "<div class='codeSection'>public abstract class Bird { }<br>public interface IFlyable<br>{<br>void Fly();<br>}<br>public class Sparrow : Bird, IFlyable<br>{<br> public void Fly() { /* l√≥gica de vuelo */ }<br>}<br>public class Ostrich : Bird<br>{<br>// No implementa IFlyable<br>}<br></div>"
      },
      
      
      
      
      
      {
        "subtitle": "4. Interface Segregation Principle (ISP)",
        "contenido": "‚ÄúNing√∫n cliente debe verse obligado a depender de m√©todos que no utiliza.‚Äù<br><b>Definici√≥n</b><br>Las interfaces deben ser espec√≠ficas y peque√±as, en lugar de contener m√©todos innecesarios para algunas clases.   <br>"
      },
      
      
      
      {
        "subtitle": "Ejemplo en C# Violaci√≥n del principio",
        "contenido": "<div class='codeSection'>public interface IWorker<br>{<br>    void Work();<br>    void Eat();<br>}<br><br>public class Robot : IWorker<br>{<br>    public void Work() { }<br>    public void Eat() { throw new NotImplementedException(); } // Un robot no come<br>}<br></div>"
      }
      ,
      {
        "subtitle": "Soluci√≥n aplicando ISP ",
        "contenido": "<div class='codeSection'>public interface IWorkable<br>{<br>    void Work();<br>}<br><br>public interface IFeedable<br>{<br>    void Eat();<br>}<br><br>public class Robot : IWorkable<br>{<br>    public void Work() { }<br>}<br><br>public class Human : IWorkable, IFeedable<br>{<br>    public void Work() { }<br>    public void Eat() { }<br>}<br></div>"
      },
      
      
      
      
      
      {
        "subtitle": "5. Dependency Inversion Principle (DIP)",
        "contenido": "Los m√≥dulos de alto nivel no deben depender de m√≥dulos de bajo nivel. Ambos deben depender de abstracciones.‚Äù<br><b>Definici√≥n</b><br> En lugar de que las clases dependan directamente de implementaciones concretas, deben depender de interfaces o abstracciones.<br>"
      },
      
      
      
      {
        "subtitle": "Ejemplo en C# Violaci√≥n del principio",
        "contenido": "<div class='codeSection'>public class MySQLDatabase<br>{<br>    public void SaveData(string data) { }<br>}<br><br>public class DataService<br>{<br>    private MySQLDatabase db = new MySQLDatabase();<br>    public void Save(string data) => db.SaveData(data);<br>}<br></div><br>DataService est√° acoplado a una implementaci√≥n concreta."
      }
      ,
      {
        "subtitle": "Soluci√≥n Aplicaci√≥n de DIP",
        "contenido": "<div class='codeSection'>public interface IDatabase<br>{<br>    void SaveData(string data);<br>}<br><br>public class MySQLDatabase : IDatabase<br>{<br>    public void SaveData(string data) { }<br>}<br><br>public class DataService<br>{<br>    private readonly IDatabase _database;<br><br>    public DataService(IDatabase database)<br>    {<br>        _database = database;<br>    }<br><br>    public void Save(string data) => _database.SaveData(data);<br>}<br></div><br>Ahora DataService puede trabajar con cualquier base de datos que implemente IDatabase."
      },            
      {
        "subtitle": "Beneficios de aplicar SOLID",
        "contenido": "<ul><li>C√≥digo modular y reutilizable</li><li>Facilita el testing automatizado</li><li>Menor riesgo de bugs al modificar c√≥digo</li><li>Mejora la colaboraci√≥n en equipo</li><li>Escalabilidad y mantenimiento a largo lazo</li></ul><br><br>"
      }
    ]
  },
    {
    "id": 3,
    "slug": "refactorizacion-explicacion",
    "title": "¬øQu√© es refactorizar y para qu√© sirve?",
    "description": "En este blog te explicare que es la refactorizaci√≥n y como la podemos aplicar a nuestro c√≥digo.",
    "author": "Carlos Valencia",
    "date": "2025-06-17",
    "tags": ["refactorizacion", "programacion", "buenas practicas"],
    "content": [
      {
        "subtitle": "¬øQue es la refactorizaci√≥n?",
        "contenido": "\"Refactorizar es mejorar la estructura interna del c√≥digo sin cambiar su comportamiento externo.\" <br>La refactorizaci√≥n de c√≥digo, o refactoring, es el proceso de reestructurar el c√≥digo fuente de un programa sin cambiar su comportamiento externo, con el objetivo de mejorar la legibilidad, mantenibilidad y eficiencia del mismo. En otras palabras, se trata de modificar el c√≥digo internamente para hacerlo m√°s f√°cil de entender, modificar y ampliar, sin afectar a la funcionalidad del programa."
      },

      {
        "subtitle": "¬øPor qu√© es importante la refactorizaci√≥n",
        "contenido": "<ul><li>Mejora la calidad del c√≥digo:</li>Al hacer que el c√≥digo sea m√°s legible y f√°cil de entender, los desarrolladores pueden identificar errores y problemas m√°s f√°cilmente. <li>Facilita la mantenci√≥n:</li>Un c√≥digo bien refactorizado es m√°s f√°cil de mantener y actualizar, lo que reduce el tiempo y los costos asociados.<li>Permite agregar nuevas funcionalidades:</li>Al hacer que el c√≥digo sea m√°s modular y reutilizable, es m√°s f√°cil agregar nuevas funcionalidades sin tener que modificar grandes partes del c√≥digo existente.<li>Aumenta la productividad de los desarrolladores:</li>El c√≥digo refactorizado es m√°s f√°cil de trabajar, lo que aumenta la productividad de los desarrolladores. <li>Reducir la deuda t√©cnica:</li>La refactorizaci√≥n ayuda a abordar la deuda t√©cnica, es decir, el c√≥digo que ha sido escrito sin seguir las mejores pr√°cticas y que eventualmente puede generar problemas.</ul>"
      },

      {
        "subtitle": "Se√±ales de \"mal dise√±o\" en JS:",
        "contenido": "<ul><li>C√≥digo duplicado</li><li>Funciones muy largas</li><li>Nombres poco descriptivos</li><li>Exceso de responsabilidad en una sola funci√≥n</li><li>Acoplamiento fuerte</li><li>C√≥digo dif√≠cil de testear</li></ul>"
      },
      {
        "subtitle": "Ejemplos pr√°cticos de refactorizaci√≥n",
        "contenido": ""
      },


      {
        "subtitle": "Ejemplo 1: Funci√≥n con responsabilidades mezcladas",
        "contenido": "C√≥digo original (antipatr√≥n)<br><div class='codeSection'><pre>function handleUser(data) {</br>&#x09;const name = data.name;</br>&#x09;const age = data.age;</br>&#x09;if (age < 18) {</br>&#x09;&#x09;console.log(\"Usuario menor de edad\");</br>&#x09;} else {</br>&#x09;&#x09;console.log(\"Usuario mayor de edad\");</br>&#x09;}</br></br>&#x09;sendToServer(data);</br>}</br></br>function sendToServer(data) {</br>&#x09;fetch(\"/api/users\", {</br>&#x09;&#x09;method: \"POST\",</br>&#x09;&#x09;body: JSON.stringify(data)</br>&#x09;});</br>}</br></pre></div>Problemas:<br><ul><li>handleUser tiene responsabilidades m√∫ltiples: validaci√≥n y env√≠o.</li><li>Dif√≠cil de testear por estar todo mezclado.</li></ul>"
      },
      
      {
        "subtitle": "Ejemplo 1: Refactorizado (mejor dise√±o)",
        "contenido": "<div class='codeSection'><pre>function isMinor(age) {</br>&#x09;return age < 18;</br>}</br></br>function logUserAgeStatus(age) {</br>&#x09;const message = isMinor(age) ? \"Usuario menor de edad\" : \"Usuario mayor de edad\";</br>&#x09;console.log(message);</br>}</br></br>function sendToServer(data) {</br>&#x09;fetch(\"/api/users\", {</br>&#x09;&#x09;method: \"POST\",</br>&#x09;&#x09;body: JSON.stringify(data)</br>&#x09;});</br>}</br></br>function handleUser(data) {</br>&#x09;logUserAgeStatus(data.age);</br>&#x09;sendToServer(data);</br>}</br></pre></div>Beneficios:<ul><li>M√°s legible</li><li>Separaci√≥n clara de responsabilidades (SRP)</li><li>F√°cil de testear cada parte</li></ul>"
      },            
      {
        "subtitle": "Ejemplo 2: C√≥digo duplicado",
        "contenido": "C√≥digo original (antipatr√≥n) <div class='codeSection'><pre>function getUserAdmin(id) {</br>&#x09;return fetch(`/api/admins/${id}`).then(res => res.json());</br>}</br></br>function getUserClient(id) {</br>&#x09;return fetch(`/api/clients/${id}`).then(res => res.json());</br>}</br></pre></div> Problema: </br>Duplicaci√≥n de l√≥gica, solo cambia la ruta."
      },


      {
        "subtitle": "Ejemplo 2: Refactorizado:",
        "contenido": "<div class='codeSection'><pre>function getUserByType(id, type) {</br>&#x09;return fetch(`/api/${type}/${id}`).then(res => res.json());</br>}</br></br>// Uso</br>getUserByType(1, \"admins\");</br>getUserByType(2, \"clients\");</br></pre></div>Beneficio:<ul><li>C√≥digo DRY (Don‚Äôt Repeat Yourself)</li><li>M√°s escalable</li></ul>"
      },      
      {
        "subtitle": "Ejemplo 3: Nombres malos y c√≥digo \"m√°gico\"",
        "contenido": "C√≥digo original (antipatr√≥n)<div class='codeSection'><pre>function d(u) {<br>&#x09;return u.l === 1 ? \"activo\" : \"inactivo\";<br>}<br></pre></div>Problema:<ul><li>Nombres no descriptivos</li><li>N√∫meros m√°gicos</li></ul>"
      },
      {
        "subtitle": "Ejemplo 3: Refactorizado:",
        "contenido": "<div class='codeSection'><pre>function getUserStatus(user) {</br>&#x09;const STATUS_ACTIVE = 1;</br>&#x09;return user.level === STATUS_ACTIVE ? \"activo\" : \"inactivo\";</br>}</br></pre></div> Mejora:<ul><li>Lectura clara</li><li>Reutilizable</li></ul>"
      },      
      {
        "subtitle": "Principios clave de refactorizaci√≥n",
        "contenido": "<table><tr><th>Principio</th><th>Aplicaci√≥n</th></tr><tr><td>SRP (Single Responsibility)</td><td>Divide funciones con m√°s de una tarea</td></tr><tr><td>DRY (Don‚Äôt Repeat Yourself)</td><td>Evita duplicaci√≥n de c√≥digo</td></tr><tr><td>KISS (Keep It Simple)</td><td>Prefiere la soluci√≥n m√°s simple posible</td></tr><tr><td>YAGNI (You Aren‚Äôt Gonna Need It)</td><td>No agregues funcionalidades innecesarias</td></tr><tr><td>Nombres descriptivos</td><td>Usa nombres claros para funciones y variables</td></tr></table> </br></br> "
      }                                                    
    ]
  },
    {
    "id": 4,
    "slug": "composition-patern",
    "title": "Composition Pattern en React",
    "description": "¬øQu√© pasar√≠a si vi√©ramos la programaci√≥n como un juego de bloques LEGO? Pues el patr√≥n de composici√≥n es b√°sicamente la respuesta a esta pregunta.",
    "author": "Carlos Valencia",
    "date": "2025-06-22",
    "tags": ["patrones", "programacion", "buenas practicas"],
    "content": [
      {
        "subtitle": "¬øQu√© es el Composition Pattern en React?",
        "contenido": "El Composition Pattern se basa en la idea de construir componentes complejos a partir de otros m√°s simples, como si fueran bloques LEGO.</br>En lugar de heredar comportamiento (como en la herencia cl√°sica de POO), en React componemos componentes </br>"
      },
      {
        "subtitle": "Concepto clave: children",
        "contenido": "Ejemplo simple</br><img class='blog-image' src=\"https://i.imgur.com/kBTPXbx.jpg\" alt=\"\" /></br>¬øQu√© pas√≥ aqu√≠?</br><ul><li>Card es un componente gen√©rico que no sabe qu√© va a renderizar.</li><li>Todo lo que se pasa entre <`Card`>...<`/Card`> se accede con props.children.</li><li>Esto permite m√°xima reutilizaci√≥n y flexibilidad.</li></ul></ul>"
      },
      {
        "subtitle": "Variaciones del Composition Pattern",
        "contenido": ""
      },
      {
        "subtitle": "1. Slot pattern con props.children (estructura libre)",
        "contenido": "<img class='blog-image' src=\"https://i.imgur.com/kCplTds.jpeg\" alt=\"\" /> </br>Ideal cuando no te importa el orden o los tipos de hijos, solo que se compongan en un contenedor."
      },
      {
        "subtitle": "2. Named slots con props personalizadas",
        "contenido": "Permite m√°s control que children.</br> <img class='blog-image' src=\"https://i.imgur.com/BBM7EzO.jpeg\" alt=\"\" /></br> √ötil cuando quieres separar secciones l√≥gicas de un componente sin imponer dise√±o r√≠gido."
      },
      {
        "subtitle": "3. Render Props (funciones como hijos)",
        "contenido": "Patr√≥n m√°s avanzado, permite compartir l√≥gica.</br><img class='blog-image' src=\"https://i.imgur.com/So9qnGu.jpeg\" alt=\"\" /></br> Ideal cuando quieres compartir l√≥gica pero delegar la UI al componente consumidor."
      },            
      {
        "subtitle": "4. Composici√≥n con Componentes Hijos Especiales (Component Injection)",
        "contenido": "<img class='blog-image' src=\"https://i.imgur.com/GWpshLS.jpeg\" alt=\"\" /></br>Muy √∫til en bibliotecas de UI como Chakra UI, Material UI, etc."
      },
      {
        "subtitle": "¬øPor qu√© usar Composition Pattern?",
        "contenido": "<table><tr><th>Ventaja</th><th>Explicaci√≥n</th></tr><tr><td>Reutilizaci√≥n</td><td>Evitas duplicar l√≥gica/estructura</td></tr><tr><td>Claridad sem√°ntica</td><td>Separas claramente estructura y contenido</td></tr><tr><td>Testeabilidad</td><td>Componentes peque√±os son m√°s f√°ciles de probar</td></tr><tr><td>Flexibilidad</td><td>Puedes inyectar diferentes contenidos f√°cilmente</td></tr><tr><td>Menos acoplamiento</td><td>Componentes no dependen del contenido que reciben</td></tr></table>"
      },      
      {
        "subtitle": "Cu√°ndo no usarlo (o usar con cuidado)",
        "contenido": "<ul><li>Si necesitas control r√≠gido de estructura ‚Üí preferir componentes m√°s espec√≠ficos.</li><li>Si tus props se vuelven demasiado complejas ‚Üí podr√≠as necesitar simplificar.</li><li>No abuses del pattern sin necesidad: la composici√≥n debe clarificar, no complicar.</li></ul>"
      },
      {
        "subtitle": "Conclusi√≥n",
        "contenido": "El Composition Pattern en React te permite escribir componentes modulares, reusables y altamente mantenibles. Es preferible a la herencia y te da el poder de construir interfaces complejas con piezas simples y desacopladas.</br></br>"
      }                                                   
    ]
  }
  ]
