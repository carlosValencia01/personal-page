[
    {
    "id": 1,
    "slug": "pilares-poo",
    "title": "Los 4 pilares fundamentales de la POO",
    "description": "La POO es un paradigma de programaci√≥n que organiza el c√≥digo en torno a objetos que representan entidades del mundo real o conceptual, Esta se basa en 4 pilares fundamentales.",
    "author": "Carlos Valencia",
    "date": "2025-06-11",
    "tags": ["poo", "programacion", "fundamentos"],
        "content": [
      {
        "subtitle": "Introducci√≥n",
        "contenido": "¬øQu√© es la Programaci√≥n Orientada a Objetos (POO)? \n La POO es un paradigma de programaci√≥n que organiza el c√≥digo en torno a objetos que representan entidades del mundo real o conceptual. Cada objeto contiene datos (atributos) y comportamiento (m√©todos). Este enfoque favorece la reutilizaci√≥n de c√≥digo, la mantenibilidad y la escalabilidad. <br> <br>"
      },
      {
        "subtitle": "Los 4 pilares fundamentales de la POO",
        "contenido": "<hr> <br> <br>"
      },
      {
        "subtitle": "1. üß¨ Abstracci√≥n",
        "contenido": "Es el proceso de ocultar los detalles internos y mostrar solo lo necesario. Permite centrarse en \"qu√© hace un objeto\" en lugar de \"c√≥mo lo hace\". <br> <br>"
      },
      {
        "subtitle": "Ventajas de la abstracci√≥n:",
        "contenido": "üü¢Reducci√≥n de complejidad. <br>üü¢Mayor claridad y enfoque en el comportamiento esencial.<br>üü¢Fomenta el uso de interfaces o clases abstractas.<br> <br>"
      },
      {
        "subtitle": "2. üõ°Ô∏è Encapsulamiento",
        "contenido": "Es la pr√°ctica de ocultar los datos internos de un objeto y permitir el acceso solo a trav√©s de m√©todos p√∫blicos (getters/setters).<br> <br>"
      },
      {
        "subtitle": "Ventajas del encapsulamiento:",
        "contenido": "üü¢Control del acceso a los datos. <br>üü¢Mejora la seguridad. <br>üü¢Reduce el acoplamiento.<br> <br>"
      },
      {
        "subtitle": "3. üß¨ Herencia",
        "contenido": "Es la capacidad de una clase de heredar propiedades y comportamientos de otra clase. Promueve la reutilizaci√≥n de c√≥digo.<br> <br>"
      },
      {
        "subtitle": "Ventajas de la herencia:",
        "contenido": "üü¢Reutilizaci√≥n de c√≥digo. <br>üü¢Organizaci√≥n jer√°rquica. <br>üü¢Extensibilidad.<br> <br>"
      },
      {
        "subtitle": "4. üîÑ Polimorfismo",
        "contenido": "Es la capacidad de un objeto de adoptar m√∫ltiples formas. Es decir, una misma acci√≥n puede comportarse de manera diferente seg√∫n el contexto.<br> <br>"
      },
      {
        "subtitle": "Ventajas del polimorfismo:",
        "contenido": "üü¢Mayor flexibilidad.<br>üü¢C√≥digo m√°s limpio y reutilizable.<br>üü¢Permite el uso de interfaces y clases base.<br> <br>"
      },
      {
        "subtitle": "¬øPor qu√© son importantes estos pilares?",
        "contenido": "üü¢Permiten dise√±ar software robusto, escalable y mantenible.<br>üü¢Separan las responsabilidades y mejoran el principio de responsabilidad √∫nica.<br>üü¢Hacen que el c√≥digo sea m√°s cercano a c√≥mo pensamos los humanos en objetos y comportamientos.<br> <br>"
      },
      {
        "subtitle": "Conclusi√≥n",
        "contenido": "La POO sigue siendo clave en la ingenier√≠a de software moderna, especialmente en lenguajes como C#, Java, Python, C++. Comprender profundamente estos pilares es esencial para cualquier desarrollador que busque escribir c√≥digo limpio, s√≥lido y orientado al cambio.<br> <br>"
      }
    ]
  },
      {
    "id": 2,
    "slug": "principios-solid",
    "title": "Principios SOLID: Gu√≠a Completa",
    "description": "Aqu√≠ tienes una gu√≠a completa y detallada sobre los Principios SOLID",
    "author": "Carlos Valencia",
    "date": "2025-06-13",
    "tags": ["solid", "programacion", "fundamentos"],

        "content": [
      {
        "subtitle": "¬øQu√© es SOLID?",
        "contenido": "SOLID es un acr√≥nimo que representa cinco principios fundamentales de la programaci√≥n orientada a objetos, formulados por Robert C. Martin (conocido como ‚ÄúUncle Bob‚Äù). Estos principios tienen como objetivo escribir c√≥digo:<br> <ul><li>M√°s limpio</li>  <li>Mantenible</li> <li>Escalable</li> <li>F√°cil de probar y extender</li></ul>"
      },
      {
        "subtitle": "1. Single Responsibility Principle (SRP)",
        "contenido": "‚ÄúUna clase debe tener una √∫nica raz√≥n para cambiar.‚Äù<br><b>Definici√≥n</b><br> Cada clase o m√≥dulo debe encargarse de una √∫nica funcionalidad o responsabilidad. Si una clase tiene m√∫ltiples razones para cambiar, est√° haciendo m√°s de lo que deber√≠a.<br>"
      },
      {
        "subtitle": "Ejemplo en C# (Violando SRP)",
        "contenido": "<div class='codeSection'>public class Report<br>{<br>public string Title { get; set; }<br>public void GenerateReport() {* l√≥gica de generaci√≥n */ }<br>    public void SaveToFile() { /* l√≥gica de guardado en disco */ }<br>}</div><br>Esta clase viola SRP porque maneja tanto la l√≥gica del reporte como la persistencia."
      }
      ,
      {
        "subtitle": "Soluci√≥n SRP",
        "contenido": "<div class='codeSection'>public class Report<br>{<br>public string Title { get; set; }<br>public void GenerateReport() { /* <br>l√≥gica de generaci√≥n */ }<br>}<br>public class ReportSaver<br>{<br>public void SaveToFile(Report report) { /* guardar en disco */ }<br>}<br></div><br>"
      }
      ,{
        "subtitle": "2. Open/Closed Principle (OCP)",
        "contenido": "‚ÄúLas entidades de software deben estar abiertas para extensi√≥n, pero cerradas para modificaci√≥n.‚Äù<br><b>Definici√≥n</b><br>El comportamiento de una clase debe poder extenderse sin necesidad de modificar su c√≥digo original.<br>"
      },            
      {
        "subtitle": "Ejemplo en C# (Violando OCP)",
        "contenido": "<div class='codeSection'>public class DiscountCalculator<br>{<br>public double Calculate(string customerType)<br>{<br>        if (customerType == \"Regular\") return 0.1;<br>if (customerType == \"Premium\") return 0.2;<br>return 0;<br>}<br>}<br></div><br>Cada vez que se agregue un nuevo tipo de cliente, se debe modificar la clase."
      }
      ,
      {
        "subtitle": "Soluci√≥n OCP aplicado (usando polimorfismo)",
        "contenido": "<div class='codeSection'>public interface IDiscount<br>{<br>double GetDiscount();<br>}<br>public class RegularDiscount :IDiscount<br>{<br>public double GetDiscount() => 0.1;<br>}<br>public class PremiumDiscount : IDiscount<br>{<br>public double GetDiscount() => 0.2;<br>}<br><br>public class DiscountCalculator<br>{<br>public double Calculate(IDiscount discount) => discount.GetDiscount();<br>}<br></div><br>"
      },
      {
        "subtitle": "3. Liskov Substitution Principle (LSP)",
        "contenido": "‚ÄúLos objetos de una clase derivada deben poder sustituir a los objetos de su clase base sin alterar el comportamiento esperado.‚Äù<br><b>Definici√≥n</b><br>Si una clase B hereda de A, deber√≠a poder usarse donde sea que se use A, sin errores ni comportamientos inesperados.<br>"
      },
      
      
      
      {
        "subtitle": "Ejemplo en C# (Violando LSP)",
        "contenido": "<div class='codeSection'>public class Bird<br>{<br>public virtual void Fly() { }<br>}<br>public class Ostrich : Bird<br>{<br>  public override void Fly() => throw new NotImplementedException(); // Las avestruces no vuelan<br>}<br></div>Si usamos Ostrich como un Bird, provocar√° errores."
      }
      ,
      {
        "subtitle": "Soluci√≥n LSP",
        "contenido": "<div class='codeSection'>public abstract class Bird { }<br>public interface IFlyable<br>{<br>void Fly();<br>}<br>public class Sparrow : Bird, IFlyable<br>{<br> public void Fly() { /* l√≥gica de vuelo */ }<br>}<br>public class Ostrich : Bird<br>{<br>// No implementa IFlyable<br>}<br></div>"
      },
      
      
      
      
      
      {
        "subtitle": "4. Interface Segregation Principle (ISP)",
        "contenido": "‚ÄúNing√∫n cliente debe verse obligado a depender de m√©todos que no utiliza.‚Äù<br><b>Definici√≥n</b><br>Las interfaces deben ser espec√≠ficas y peque√±as, en lugar de contener m√©todos innecesarios para algunas clases.   <br>"
      },
      
      
      
      {
        "subtitle": "Ejemplo en C# Violaci√≥n del principio",
        "contenido": "<div class='codeSection'>public interface IWorker<br>{<br>    void Work();<br>    void Eat();<br>}<br><br>public class Robot : IWorker<br>{<br>    public void Work() { }<br>    public void Eat() { throw new NotImplementedException(); } // Un robot no come<br>}<br></div>"
      }
      ,
      {
        "subtitle": "Soluci√≥n aplicando ISP ",
        "contenido": "<div class='codeSection'>public interface IWorkable<br>{<br>    void Work();<br>}<br><br>public interface IFeedable<br>{<br>    void Eat();<br>}<br><br>public class Robot : IWorkable<br>{<br>    public void Work() { }<br>}<br><br>public class Human : IWorkable, IFeedable<br>{<br>    public void Work() { }<br>    public void Eat() { }<br>}<br></div>"
      },
      
      
      
      
      
      {
        "subtitle": "5. Dependency Inversion Principle (DIP)",
        "contenido": "Los m√≥dulos de alto nivel no deben depender de m√≥dulos de bajo nivel. Ambos deben depender de abstracciones.‚Äù<br><b>Definici√≥n</b><br> En lugar de que las clases dependan directamente de implementaciones concretas, deben depender de interfaces o abstracciones.<br>"
      },
      
      
      
      {
        "subtitle": "Ejemplo en C# Violaci√≥n del principio",
        "contenido": "<div class='codeSection'>public class MySQLDatabase<br>{<br>    public void SaveData(string data) { }<br>}<br><br>public class DataService<br>{<br>    private MySQLDatabase db = new MySQLDatabase();<br>    public void Save(string data) => db.SaveData(data);<br>}<br></div><br>DataService est√° acoplado a una implementaci√≥n concreta."
      }
      ,
      {
        "subtitle": "Soluci√≥n Aplicaci√≥n de DIP",
        "contenido": "<div class='codeSection'>public interface IDatabase<br>{<br>    void SaveData(string data);<br>}<br><br>public class MySQLDatabase : IDatabase<br>{<br>    public void SaveData(string data) { }<br>}<br><br>public class DataService<br>{<br>    private readonly IDatabase _database;<br><br>    public DataService(IDatabase database)<br>    {<br>        _database = database;<br>    }<br><br>    public void Save(string data) => _database.SaveData(data);<br>}<br></div><br>Ahora DataService puede trabajar con cualquier base de datos que implemente IDatabase."
      },

      
      
      {
        "subtitle": "Beneficios de aplicar SOLID",
        "contenido": "<ul><li>C√≥digo modular y reutilizable</li><li>Facilita el testing automatizado</li><li>Menor riesgo de bugs al modificar c√≥digo</li><li>Mejora la colaboraci√≥n en equipo</li><li>Escalabilidad y mantenimiento a largo lazo</li></ul><br><br>"
      }
    ]
  }
  ]
